---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chaoguan.
--- DateTime: 2021/10/9 11:40
---

local RMMotion = require("Runtime.Battle.Logic.RMAnimator.RMMotion")

---@class RMBlendTreeType
RMBlendTreeType = {
    Simple1D = 0,
    SimpleDirectional2D = 1,
    FreeformDirectional2D = 2,
    FreeformCartesian2D = 3,
    Direct = 4,
}

---@class RMBlendTree:RMMotion
---@field minThreshold Float
---@field maxThreshold Float
---@field blendParameterName String
---@field blendType RMBlendTreeType
---@field childMotions RMBlendTreeChild[]
local RMBlendTree = XECS.class("RMBlendTree", RMMotion)

function RMBlendTree:ctor(ctrl, minThreshold, maxThreshold, blendParameterName, blendType, childMotions)
    RMMotion.ctor(self)
    self.minThreshold = minThreshold
    self.maxThreshold = maxThreshold
    self.blendParameterName = blendParameterName
    self.blendType = blendType
    self.childMotions = childMotions or {}
    self.length = #childMotions > 0 and childMotions[1].length or ctrl.context.fOne
    self.isLoop = true
end

function RMBlendTree:OnEnter(startingTime)
    self.normalizedTime = startingTime / self.length
    for _, motion in ipairs(self.childMotions) do
        motion:OnEnter(self.normalizedTime * motion.length)
    end
end

function RMBlendTree:SetWeight(weight)
    self.weight = weight
end

function RMBlendTree:SetTime(runningTime)
    local boundedTime, repeatedCount = runningTime, 0
    while boundedTime > self.length do
        boundedTime = boundedTime - self.length
        repeatedCount = repeatedCount + 1
    end

    self.repeatedCount = repeatedCount
    self.normalizedTime = runningTime / self.length
    for _, motion in ipairs(self.childMotions) do
        motion:SetTime(self.normalizedTime * motion.length)
    end
end

function RMBlendTree:Evaluate()
    local deltaPos, deltaAngleY = self._ctrl.context:V3TempZero(), self._ctrl.context:FTempZero()
    for _, motion in ipairs(self.childMotions) do
        local pos, angleY = motion:Evaluate()
        deltaPos = self._ctrl.context:V3AddEqualTo(deltaPos, pos)
        deltaAngleY = self._ctrl.context:FAddEqualTo(deltaAngleY, angleY)
    end

    return self._ctrl.context:V3MulEqualTo(deltaPos, self.weight), self._ctrl.context:FMulEqualTo(deltaAngleY, self.weight)
end

function RMBlendTree:DeepCopy()
    local childMotions = {}
    for _, motion in ipairs(self.childMotions) do
        table.insert(childMotions, motion:DeepCopy())
    end
    return RMBlendTree.new(self._ctrl, self.minThreshold, self.maxThreshold, self.blendParameterName, self.blendType, childMotions)
end

---@return boolean
function RMBlendTree:IsValid(ctrl)
    for _, motion in ipairs(self.childMotions) do
        if not motion:IsValid(self._ctrl) then
            return false
        end
    end
    return self._ctrl == ctrl and self._isValid
end

---@param ctrl RMAnimatorController
function RMBlendTree:Rebuild(ctrl, eventNotifyFunc)
    self._ctrl = ctrl
    self._isValid = true

    for _, motion in ipairs(self.childMotions) do
        motion:Rebuild(ctrl, eventNotifyFunc)
    end

    local parameter = ctrl:GetParameter(self.blendParameterName)
    if parameter then
        parameter.onValueChanged:RemoveListener(self, self._OnParameterValueChanged)
        parameter.onValueChanged:AddListener(self, self._OnParameterValueChanged)
        self:_SetChildWeight(parameter.value)
    else
        self:_SetChildWeight(self._ctrl.context.fZero)
    end
end

---@param parameter RMAnimatorParameter
function RMBlendTree:_OnParameterValueChanged(parameter)
    if not parameter or not self._ctrl or parameter.ctrl ~= self._ctrl or parameter.name ~= self.blendParameterName then
        return
    end
    if not self:IsValid(self._ctrl) then
        self:Rebuild(self._ctrl)
    end

    self:_SetChildWeight(parameter.value)
end

function RMBlendTree:_SetChildWeight(threshold)
    if threshold < self.minThreshold then
        threshold = self.minThreshold
    elseif threshold > self.maxThreshold then
        threshold = self.maxThreshold
    end

    local childCount = #self.childMotions
    if childCount == 1 then
        self.childMotions[1]:SetWeight(self._ctrl.context.fOne)
    elseif childCount > 1 then
        local index = 0
        while index < childCount do
            if index < childCount - 1 and threshold >= self.childMotions[index + 1].threshold and threshold <= self.childMotions[index + 2].threshold then
                local weight = (threshold - self.childMotions[index + 1].threshold) / (self.childMotions[index + 2].threshold - self.childMotions[index + 1].threshold)
                self.childMotions[index + 1]:SetWeight(self._ctrl.context.fOne - weight)
                self.childMotions[index + 2]:SetWeight(weight)
                index = index + 2
            else
                self.childMotions[index + 1]:SetWeight(self._ctrl.context.fZero)
                index = index + 1
            end
        end
    end

    self.length = self._ctrl.context.fZero
    for _, motion in ipairs(self.childMotions) do
        self.length = self.length + motion.weight * motion.length
    end
end

return RMBlendTree