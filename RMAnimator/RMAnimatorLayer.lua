---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chaoguan.
--- DateTime: 2021/10/9 11:38
---

---@class ToState
---@field name String
---@field dValue Float
---@field offsetTime Float
---@field transitionTime Float
---@field isNormalizedTime Boolean
---@field toEvent fun()
local ToState = XECS.class("ToState")

function ToState:ctor(func)
    self.toEvent = func
end

function ToState:SetValue(isNormalizedTime, name, dValue, offsetTime, transitionTime)
    self.isNormalizedTime = isNormalizedTime
    self.name = name
    self.dValue = dValue
    self.offsetTime = offsetTime
    self.transitionTime = transitionTime
end

function ToState:Switch()
    if not self.name or not self.toEvent then
        return false
    end
    self.toEvent(self.isNormalizedTime, self.name, self.dValue, self.offsetTime, self.transitionTime)
    self.name = nil
    return true
end

---@class RMAnimatorLayer
---@field name String
---@field defaultSpeed Float
---@field defaultStateName String
---@field states RMAnimatorState[]
---@field _oldestState RMAnimatorState
---@field _prevState RMAnimatorState
---@field _currState RMAnimatorState
---@field _toNextState ToState
local RMAnimatorLayer = XECS.class("RMAnimatorLayer")

function RMAnimatorLayer:ctor(name, defaultSpeed, defaultStateName, states)
    self.name = name
    self.defaultSpeed = defaultSpeed
    self.defaultStateName = defaultStateName
    self.states = states
end

function RMAnimatorLayer:OnStart()
    if self._currState then
        return
    end
    self:_SwitchState(true, self.defaultStateName, self._ctrl.context.fZero, self._ctrl.context.fZero, self._ctrl.context.fZero)
end

function RMAnimatorLayer:OnUpdate(deltaTime)
    deltaTime = deltaTime * self.defaultSpeed
    if self._toNextState:Switch() then
        self:_BlendState(deltaTime, self._ctrl.context.fZero, deltaTime)
    else
        self:_BlendState(deltaTime, deltaTime, deltaTime)
    end
end

function RMAnimatorLayer:Evaluate()
    local deltaPos, deltaAngleY = self._ctrl.context:V3TempZero(), self._ctrl.context:FTempZero()
    if self._prevState then
        local pos, angleY = self._prevState:Evaluate()
        deltaPos = self._ctrl.context:V3AddEqualTo(deltaPos, pos)
        deltaAngleY = self._ctrl.context:FAddEqualTo(deltaAngleY, angleY)
    end
    if self._currState then
        local pos, angleY = self._currState:Evaluate()
        deltaPos = self._ctrl.context:V3AddEqualTo(deltaPos, pos)
        deltaAngleY = self._ctrl.context:FAddEqualTo(deltaAngleY, angleY)
    end
    self._ctrl.context:TransformRotate(deltaAngleY)
    self._ctrl.context:TransformTranslate(deltaPos)
end

function RMAnimatorLayer:OnDestroy()
    for _, state in ipairs(self.states) do
        state:OnDestroy()
    end
end

---@param speed Float
function RMAnimatorLayer:SetSpeed(speed)
    self.defaultSpeed = speed
end

---@param stateName String
---@param normalizedTime Float
function RMAnimatorLayer:Play(stateName, normalizedTime)
    if not self:_CanToState(stateName, normalizedTime) then
        return
    end

    self._toNextState:SetValue(true, stateName, self._ctrl.context.fZero, normalizedTime, self._ctrl.context.fZero)
end

---@param stateName String
---@param fixedTime Float
function RMAnimatorLayer:PlayInFixedTime(stateName, fixedTime)
    if not self:_CanToState(stateName, fixedTime) then
        return
    end
    self._toNextState:SetValue(false, stateName, self._ctrl.context.fZero, fixedTime, self._ctrl.context.fZero)
end

---@param stateName String
---@param normalizedOffsetTime Float
---@param normalizedTransitionTime Float
function RMAnimatorLayer:CrossFade(stateName, normalizedOffsetTime, normalizedTransitionTime)
    if not self:_CanToState(stateName, normalizedOffsetTime) then
        return
    end
    self._toNextState:SetValue(true, stateName, self._ctrl.context.fZero, normalizedOffsetTime, normalizedTransitionTime)
end

---@param stateName String
---@param fixedOffsetTime Float
---@param fixedTransitionTime Float
function RMAnimatorLayer:CrossFadeInFixedTime(stateName, fixedOffsetTime, fixedTransitionTime)
    if not self:_CanToState(stateName, fixedOffsetTime) then
        return
    end
    self._toNextState:SetValue(false, stateName, self._ctrl.context.fZero, fixedOffsetTime, fixedTransitionTime)
end

---@param stateName String
---@param dValue Float
---@param normalizedOffsetTime Float
---@param normalizedTransitionTime Float
function RMAnimatorLayer:InternalCrossFade(stateName, dValue, normalizedOffsetTime, normalizedTransitionTime)
    if self._blendTick > self._ctrl.context.fZero then
        --- Debug.Log($"[playable animator][frameCount:{Time.frameCount}][正在过渡状态，请稍候...]");
        return
    end
    self._toNextState:SetValue(true, stateName, dValue, normalizedOffsetTime, normalizedTransitionTime)
    self:OnUpdate(self._ctrl.context.fZero)
end

---@param state table RMAnimatorState
function RMAnimatorLayer:AddState(state)
    if not state or self:HasState(state.name) then
        return
    end
    table.insert(self.states, state)
end

function RMAnimatorLayer:RemoveState(stateName)
    if not stateName then
        return
    end
    for i, state in ipairs(self.states) do
        if state.name == stateName then
            table.remove(self.states, i)
            break
        end
    end
end

---@param stateName String
function RMAnimatorLayer:HasState(stateName)
    return nil ~= self:GetState(stateName)
end

---@param stateName String
function RMAnimatorLayer:GetState(stateName)
    if not stateName then
        return nil
    end
    for _, state in ipairs(self.states) do
        if state.name == stateName then
            return state
        end
    end
    return nil
end

---@param stateName String
function RMAnimatorLayer:GetStateLength(stateName)
    local state = self:GetState(stateName)
    if not state then
        return self._ctrl.context.fZero
    end
    return state:Length()
end

---@param stateName String
---@param speed Float
function RMAnimatorLayer:SetStateSpeed(stateName, speed)
    local state = self:GetState(stateName)
    if not state then
        return
    end
    state:SetSpeed(speed)
end

---@return RMAnimatorStateInfo
function RMAnimatorLayer:GetPreviousStateInfo()
    if self._prevState then
        ---@type RMAnimatorStateInfo
        if not self._prevStateInfo then
            self._prevStateInfo = {}
        end
        self._prevStateInfo.name = self._prevState.name
        self._prevStateInfo.tag = self._prevState.tag
        self._prevStateInfo.speed = self._prevState.speed
        self._prevStateInfo.isLooping = self._prevState:IsLoop()
        self._prevStateInfo.length = self._prevState:Length() or self._ctrl.fZero
        self._prevStateInfo.normalizedTime = self._prevState:NormalizedTime() or self._ctrl.fZero
        self._prevStateInfo.repeatedCount = self._prevState:RepeatedCount() or self._ctrl.fZero
        self._prevStateInfo.formSubStateMachineName = self._prevState.formSubStateMachineName
    else
        self._prevStateInfo = {}
    end
    return self._prevStateInfo
end

---@return RMAnimatorStateInfo
function RMAnimatorLayer:GetCurrentStateInfo()
    if self._currState then
        if not self._currStateInfo then
            ---@type RMAnimatorStateInfo
            self._currStateInfo = {}
        end
        self._currStateInfo.name = self._currState.name
        self._currStateInfo.tag = self._currState.tag
        self._currStateInfo.speed = self._currState.speed
        self._currStateInfo.isLooping = self._currState:IsLoop()
        self._currStateInfo.length = self._currState:Length() or self._ctrl.fZero
        self._currStateInfo.normalizedTime = self._currState:NormalizedTime() or self._ctrl.fZero
        self._currStateInfo.repeatedCount = self._currState:RepeatedCount() or self._ctrl.fZero
        self._currStateInfo.formSubStateMachineName = self._currState.formSubStateMachineName
    else
        self._currStateInfo = {}
    end
    return self._currStateInfo
end

---@return boolean
function RMAnimatorLayer:IsValid(ctrl)
    return self._ctrl == ctrl and self._isValid
end

---@param ctrl RMAnimatorController
---@param stateNotifyFunc fun(...)
---@param eventNotifyFunc fun(...)
function RMAnimatorLayer:Rebuild(ctrl, stateNotifyFunc, eventNotifyFunc)
    self._ctrl = ctrl
    self._isValid = true
    self._stateNotifyFunc = stateNotifyFunc
    self._eventNotifyFunc = eventNotifyFunc
    self._toNextState = self._toNextState or ToState.new(function(...)
        self:_SwitchState(...)
    end)

    if self._prevState then
        self._prevState:Rebuild(self._ctrl, function(...)
            self:InternalCrossFade(...)
        end, self._stateNotifyFunc, self._eventNotifyFunc)
    end
    if self._currState then
        self._currState:Rebuild(self._ctrl, function(...)
            self:InternalCrossFade(...)
        end, self._stateNotifyFunc, self._eventNotifyFunc)
    end
end

---@param stateName String
---@param offsetTime Float
function RMAnimatorLayer:_CanToState(stateName, offsetTime)
    if nil == offsetTime and nil ~= self._currState and self._currState.name == stateName then
        --- Debug.Log($"[playable animator][frameCount:{Time.frameCount}][当前状态正在播放][{currState.name}]");
        return false
    end
    return true
end

---@param isNormalizedTime Boolean
---@param stateName String
---@param dValue Float
---@param offsetTime Float
---@param transitionTime Float
function RMAnimatorLayer:_SwitchState(isNormalizedTime, stateName, dValue, offsetTime, transitionTime)
    if isNormalizedTime then
        self:_SwitchStateInNormalizedTime(self:GetState(stateName), dValue, offsetTime, transitionTime)
    else
        self:_SwitchStateInFixedTime(self:GetState(stateName), dValue, offsetTime, transitionTime)
    end
end

---@param state RMAnimatorState
---@param dValue Float
---@param normalizedOffsetTime Float
---@param normalizedTransitionTime Float
function RMAnimatorLayer:_SwitchStateInNormalizedTime(state, dValue, normalizedOffsetTime, normalizedTransitionTime)
    if not state then
        return
    end
    normalizedOffsetTime = normalizedOffsetTime or self._ctrl.context.fZero
    normalizedTransitionTime = normalizedTransitionTime or self._ctrl.context.fZero
    local fixedOffsetTime = normalizedOffsetTime * state:Length()
    local fixedTransitionTime = nil == self._currState and self._ctrl.context.fZero or normalizedTransitionTime * self._currState:Length()
    self:_SwitchStateInFixedTime(state, dValue, fixedOffsetTime, fixedTransitionTime)
end

---@param state RMAnimatorState
---@param dValue Float
---@param fixedOffsetTime Float
---@param fixedTransitionTime Float
function RMAnimatorLayer:_SwitchStateInFixedTime(state, dValue, fixedOffsetTime, fixedTransitionTime)
    if not state then
        return
    end
    fixedOffsetTime = fixedOffsetTime or self._ctrl.context.fZero
    fixedTransitionTime = fixedTransitionTime or self._ctrl.context.fZero

    if fixedTransitionTime > self._ctrl.context.fZero and state == self._currState then
        state = state:DeepCopy()
    end

    if not state:IsValid(self._ctrl) then
        state:Rebuild(self._ctrl, function(...)
            self:InternalCrossFade(...)
        end, self._stateNotifyFunc, self._eventNotifyFunc)
    end

    self._blendTime = fixedTransitionTime
    self._blendTick = fixedTransitionTime

    self._oldestState = self._prevState
    if self._prevState then
        self._prevState:OnExit(self._ctrl.context.fZero, state)
    end

    self._prevState = self._currState
    if self._prevState then
        self._prevState:OnExit(fixedTransitionTime - dValue, state)
    end

    self._currState = state
    self._currState:OnEnter(fixedOffsetTime, self._prevState)
    self._prevState = self._prevState == self._currState and self._oldestState or self._prevState
    self._stateNotifyFunc(RMStateNotifyType.CrossFade, state.name, dValue, fixedOffsetTime, fixedTransitionTime)

    self:_BlendState(dValue, dValue, self._ctrl.context.fZero)
end

---@param deltaTime Float
---@param currDelta Float
---@param prevDelta Float
function RMAnimatorLayer:_BlendState(deltaTime, currDelta, prevDelta)
    if self._blendTick > self._ctrl.context.fZero then
        self._blendTick = self._blendTick - deltaTime
        self._blendWeight = self._ctrl.context:Clamp01(self._blendTick / self._blendTime)
    elseif self._blendTick == self._ctrl.context.fZero then
        self._blendTick = self._blendTick - deltaTime
        self._blendWeight = self._ctrl.context.fZero
    end

    if self._prevState then
        self._prevState:OnUpdate(prevDelta, self._blendWeight)
    end
    if self._currState then
        self._currState:OnUpdate(currDelta, self._ctrl.context.fOne - self._blendWeight)
    end
end

return RMAnimatorLayer