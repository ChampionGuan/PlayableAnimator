---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chaoguan.
--- DateTime: 2021/10/9 11:41
---

local RMCurve = require("Runtime.Battle.Logic.RMAnimator.RMCurve")
local RMMotion = require("Runtime.Battle.Logic.RMAnimator.RMMotion")
local RMClipEvent = require("Runtime.Battle.Logic.RMAnimator.RMClipEvent")

---@class RMClipMotion:RMMotion
local RMClipMotion = XECS.class("RMClipMotion", RMMotion)

---@param ctrl RMAnimatorController
---@param clipInfo AnimatorClipInfo
---@param clipEvents FrameEvent[]
function RMClipMotion:ctor(ctrl, clipInfo, clipEvents)
    RMMotion.ctor(self)
    self._ctrl = ctrl
    ---@type AnimatorClipInfo
    self._clipInfo = clipInfo
    ---@type FrameEvent[]
    self._clipEvents = clipEvents
    ---@type RMCurve
    self._curve = RMCurve.new(ctrl, clipInfo.path, clipInfo.length)
    ---@type RMClipEvent
    self._event = RMClipEvent.new(ctrl, self._clipEvents, clipInfo.length)
    self._startPos = ctrl.context:V3Zero()
    self._endPos = ctrl.context:V3Zero()
    self._lastPos = ctrl.context:V3Zero()
    self.isLoop = clipInfo.isLoop
    self.length = clipInfo.length or self._curve.length
end

function RMClipMotion:OnEnter(startingTime)
    self._boundedTime = startingTime
    self._runningTime = startingTime
    self._deltaTime = self._ctrl.context.fZero
    self._event:Restart(startingTime, self._eventNotifyFunc)
    self._lastPos, self._lastAngleY = self:_InternalCopy(self._lastPos, self._lastAngleY, self._curve:Evaluate(startingTime))
end

function RMClipMotion:OnExit()
end

function RMClipMotion:SetWeight(weight)
    self.weight = weight
end

function RMClipMotion:SetTime(runningTime)
    local boundedTime, repeatedCount = runningTime, 0
    while boundedTime > self.length do
        boundedTime = boundedTime - self.length
        repeatedCount = repeatedCount + 1
    end

    self._deltaTime = self._deltaTime + (runningTime - self._runningTime)
    self._runningTime = runningTime
    self._boundedTime = self.isLoop and boundedTime or runningTime
    self.repeatedCount = repeatedCount
    self.normalizedTime = self._boundedTime / self.length
end

function RMClipMotion:Evaluate()
    if self._deltaTime <= self._ctrl.context.fZero then
        return self._ctrl.context:V3TempZero(), self._ctrl.context:FTempZero()
    end

    self:_EvaluateEvent()
    local deltaPos, deltaAngleY = self:_EvaluateCurve()

    self._deltaTime = self._ctrl.context.fZero
    return deltaPos, deltaAngleY
end

function RMClipMotion:DeepCopy()
    return RMClipMotion.new(self._ctrl, self._clipInfo, self._clipEvents)
end

---@return boolean
function RMClipMotion:IsValid(ctrl)
    return self._ctrl == ctrl and self._isValid
end

---@param ctrl RMAnimatorController
function RMClipMotion:Rebuild(ctrl, eventNotifyFunc)
    self._ctrl = ctrl
    self._isValid = true
    self._eventNotifyFunc = eventNotifyFunc
    self._endPos, self._endAngleY = self:_InternalCopy(self._endPos, self._endAngleY, self._curve:Evaluate(self._curve.length))
    self._startPos, self._startAngleY = self:_InternalCopy(self._startPos, self._startAngleY, self._curve:Evaluate(ctrl.context.fZero))
    self._lastPos, self._lastAngleY = self:_InternalCopy(self._lastPos, self._lastAngleY, self._startPos, self._startAngleY)
end

function RMClipMotion:_EvaluateCurve()
    local context = self._ctrl.context
    local deltaPos, deltaAngleY = context:V3TempZero(), context:FTempZero()
    local currPos, currAngleY = self._curve:Evaluate(self._boundedTime)
    if self._boundedTime - self._deltaTime >= context.fZero then
        deltaPos = context:V3AddEqualTo(deltaPos, currPos, context:V3Unm(context:V3TempZero(), self._lastPos))
        deltaAngleY = context:FAddEqualTo(deltaAngleY, currAngleY, -self._lastAngleY)
    else
        deltaPos = context:V3AddEqualTo(deltaPos, currPos, context:V3Unm(context:V3TempZero(), self._startPos), self._endPos, context:V3Unm(context:V3TempZero(), self._lastPos))
        deltaAngleY = context:FAddEqualTo(deltaAngleY, currAngleY, -self._startAngleY, self._endAngleY, -self._lastAngleY)
    end
    self._lastPos, self._lastAngleY = self:_InternalCopy(self._lastPos, self._lastAngleY, currPos, currAngleY)

    ---约束在(-180-180)
    if deltaAngleY < -context.f180 then
        deltaAngleY = deltaAngleY + context.f360
    elseif deltaAngleY > context.f180 then
        deltaAngleY = context.f360 - deltaAngleY
    end

    deltaPos = context:PointRotate(deltaPos, -self._lastAngleY)
    return context:V3MulEqualTo(deltaPos, self.weight), context:FMulEqualTo(deltaAngleY, self.weight)
end

function RMClipMotion:_EvaluateEvent()
    if not self._eventNotifyFunc or self.weight <= self._ctrl.context.fZero then
        return
    end

    self._event:Evaluate(self._deltaTime)
end

function RMClipMotion:_InternalCopy(pos, angleY, fromPos, fromAngleY)
    pos = self._ctrl.context:V3Copy(pos, fromPos)
    angleY = fromAngleY
    return pos, angleY
end

return RMClipMotion