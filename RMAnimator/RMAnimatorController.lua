---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chaoguan.
--- DateTime: 2021/10/9 11:37
---

---@alias Vector3 Vector3|FVector3
---@alias Float number|Fix
---@alias Int number
---@alias String string
---@alias Boolean boolean
---@alias Object any

---@class AnimatorCtrlConfig
---@field name string
---@field parameters table<number,AnimatorCtrlParameterConfig>
---@field layers table<string,AnimatorCtrlLayerConfig>

---@class AnimatorCtrlParameterConfig
---@field name string
---@field value number

---@class AnimatorCtrlLayerConfig
---@field name string
---@field defaultSpeed Float
---@field defaultWeight Float
---@field defaultStateName string
---@field blendingType Int
---@field anyStateTransitions AnimatorStateTransitionConfig[]
---@field states table<number,AnimatorStateConfig>

---@class AnimatorStateConfig
---@field name string
---@field tag string
---@field defaultSpeed Float
---@field speedParameterName string
---@field speedParameterActive boolean
---@field transitions table<number,AnimatorStateTransitionConfig>
---@field blendTree AnimatorBlendTreeConfig
---@field soloClip AnimatorClipInfo
---@field formSubStateMachineName string

---@class AnimatorStateTransitionConfig
---@field solo boolean
---@field mute boolean
---@field hasExitTime boolean
---@field hasFixedDuration boolean
---@field offset Float
---@field exitTime Float
---@field duration Float
---@field destinationStateName string
---@field conditions table<number,AnimatorTransitionConditionConfig>

---@class AnimatorTransitionConditionConfig
---@field type Int
---@field parameterName string
---@field threshold Float

---@class AnimatorBlendTreeConfig
---@field blendParameterName string
---@field blendType Int
---@field minThreshold Float
---@field maxThreshold Float
---@field childMotions table<number,AnimatorBlendTreeChildConfig>

---@class AnimatorBlendTreeChildConfig
---@field threshold Float
---@field clip AnimatorClipInfo

---@class AnimatorClipInfo
---@field path string
---@field name string
---@field hashID string
---@field length Float
---@field isLoop boolean

require("Runtime.Battle.XECS.XECS")

---@class RMStateNotifyType
RMStateNotifyType = {
    ---fun(layerIndex:Int,RMStateNotifyType.PrepEnter,stateName:String) 
    PrepEnter = 0,
    ---fun(layerIndex:Int,RMStateNotifyType.Enter,stateName:String) 
    Enter = 1,
    ---fun(layerIndex:Int,RMStateNotifyType.PrepExit,stateName:String) 
    PrepExit = 2,
    ---fun(layerIndex:Int,RMStateNotifyType.Exit,stateName:String) 
    Exit = 3,
    ---fun(layerIndex:Int,RMStateNotifyType.Complete,stateName:String) 
    Complete = 4,
    ---fun(layerIndex:Int,RMStateNotifyType.CrossFade,stateName:String,dValue:Float,fixedOffsetTime:Float,fixedTransitionTime:Float) 
    CrossFade = 5,
}

---@class RMAnimatorStatusType
local EInternalStatusType = {
    None = -1,
    Invalid = 0,
    Running = 1,
}

---@type RMAnimatorEvent
local RMAnimatorEvent = require("Runtime.Battle.Logic.RMAnimator.RMAnimatorEvent")

---@class RMAnimatorController
---@field speed Float
---@field animator RMAnimator
---@field context RMAnimatorContext
---@field stateNotify RMAnimatorEvent fun(layerIndex:Int,notifyType:RMStateNotifyType,stateName:String)
---@field eventNotify RMAnimatorEvent fun(eventName:string, eventArgs:table<string,any>)
---@field onPrevUpdateTick RMAnimatorEvent
---@field onLateUpdateTick RMAnimatorEvent
---@field _state RMAnimatorStatusType
---@field _layers RMAnimatorLayer[]
---@field _parameters RMAnimatorParameter[]
local RMAnimatorController = XECS.class("RMAnimatorController")

---@param context RMAnimatorContext
function RMAnimatorController:ctor(context)
    self._layers = {}
    self._parameters = {}
    self._state = EInternalStatusType.Running
    self.context = context
    self.speed = self.context.fOne
    self.stateNotify = RMAnimatorEvent.new()
    self.eventNotify = RMAnimatorEvent.new()
    self.onPrevUpdateTick = RMAnimatorEvent.new()
    self.onLateUpdateTick = RMAnimatorEvent.new()
end

function RMAnimatorController:OnStart()
    if self._state ~= EInternalStatusType.Running then
        return
    end
    for _, parameter in ipairs(self._parameters) do
        parameter:OnStart()
    end
    for _, layer in ipairs(self._layers) do
        layer:OnStart()
    end
end

---@param deltaTime Float
function RMAnimatorController:OnUpdate(deltaTime)
    deltaTime = deltaTime * self.speed
    if self._state ~= EInternalStatusType.Running then
        return
    end
    self.onPrevUpdateTick:Invoke()

    for _, layer in ipairs(self._layers) do
        if not layer:IsValid(self) then
            local index = _
            self:_RebuildLayer(index, layer)
        end
        layer:OnUpdate(deltaTime)
    end
    for _, parameter in ipairs(self._parameters) do
        parameter:OnUpdate(self)
    end

    self.onLateUpdateTick:Invoke()

    for _, layer in ipairs(self._layers) do
        layer:Evaluate()
    end
end

function RMAnimatorController:OnDestroy()
    for _, layer in ipairs(self._layers) do
        layer:OnDestroy()
    end
    for _, parameter in ipairs(self._parameters) do
        parameter:OnDestroy()
    end
    self._layers = {}
    self._parameters = {}
    self.onPrevUpdateTick:Clear()
    self.onLateUpdateTick:Clear()
    self.stateNotify:Clear()
end

---@param stateName String
---@param layerIndex Int
---@param normalizedTime Float
function RMAnimatorController:Play(stateName, layerIndex, normalizedTime)
    layerIndex = layerIndex or 1
    if self._layers[layerIndex] then
        self._layers[layerIndex]:Play(stateName, normalizedTime)
    end
end

---@param stateName String
---@param layerIndex Int
---@param fixedTime Float
function RMAnimatorController:PlayInFixedTime(stateName, layerIndex, fixedTime)
    layerIndex = layerIndex or 1
    if self._layers[layerIndex] then
        self._layers[layerIndex]:PlayInFixedTime(stateName, fixedTime)
    end
end

---@param stateName String
---@param normalizedTransitionTime Float
---@param layerIndex Int
---@param normalizedOffsetTime Float
function RMAnimatorController:CrossFade(stateName, normalizedTransitionTime, layerIndex, normalizedOffsetTime)
    layerIndex = layerIndex or 1
    if self._layers[layerIndex] then
        self._layers[layerIndex]:CrossFade(stateName, normalizedOffsetTime, normalizedTransitionTime)
    end
end

---@param stateName String
---@param fixedTransitionTime Float
---@param layerIndex Int
---@param fixedOffsetTime Float
function RMAnimatorController:CrossFadeInFixedTime(stateName, fixedTransitionTime, layerIndex, fixedOffsetTime)
    layerIndex = layerIndex or 1
    if self._layers[layerIndex] then
        self._layers[layerIndex]:CrossFadeInFixedTime(stateName, fixedOffsetTime, fixedTransitionTime)
    end
end

---@param stateName String
---@param layerIndex Int
function RMAnimatorController:HasState(stateName, layerIndex)
    layerIndex = layerIndex or 1
    if self._layers[layerIndex] then
        return self._layers[layerIndex]:HasState(stateName)
    end
    return false
end

---@param state RMAnimatorState
---@param layerIndex Int
function RMAnimatorController:AddState(state, layerIndex)
    layerIndex = layerIndex or 1
    if self._layers[layerIndex] then
        return self._layers[layerIndex]:AddState(state)
    end
    return false
end

---@param stateName String
function RMAnimatorController:GetState(stateName, layerIndex)
    layerIndex = layerIndex or 1
    if self._layers[layerIndex] then
        return self._layers[layerIndex]:GetState(stateName)
    end
end

---@param stateName String
function RMAnimatorController:GetStateLength(stateName, layerIndex)
    layerIndex = layerIndex or 1
    if self._layers[layerIndex] then
        return self._layers[layerIndex]:GetStateLength(stateName)
    end
end

---@param stateName String
---@param layerIndex Int
---@param speed Float
function RMAnimatorController:SetStateSpeed(stateName, layerIndex, speed)
    layerIndex = layerIndex or 1
    if self._layers[layerIndex] then
        self._layers[layerIndex]:SetStateSpeed(stateName, speed or self.context.fOne)
    end
end

---@param layerIndex Int
---@param speed Float
function RMAnimatorController:SetLayerSpeed(layerIndex, speed)
    layerIndex = layerIndex or 1
    if self._layers[layerIndex] then
        self._layers[layerIndex]:SetSpeed(speed or self.context.fOne)
    end
end

---@return RMAnimatorStateInfo
function RMAnimatorController:GetPreviousStateInfo(layerIndex)
    layerIndex = layerIndex or 1
    return self._layers[layerIndex] and self._layers[layerIndex]:GetPreviousStateInfo() or {}
end

---@return RMAnimatorStateInfo
function RMAnimatorController:GetCurrentStateInfo(layerIndex)
    layerIndex = layerIndex or 1
    return self._layers[layerIndex] and self._layers[layerIndex]:GetCurrentStateInfo() or {}
end

---@param name String
---@return any
function RMAnimatorController:GetParameterValue(name)
    local parameter = self:GetParameter(name)
    if parameter then
        return parameter.value
    end
end

---@param name String
---@param value any
function RMAnimatorController:SetParameterValue(name, value)
    ---@type RMAnimatorParameter
    local parameter = self:GetParameter(name)
    if parameter then
        parameter:SetValue(value)
    end
end

---@param name String
---@return RMAnimatorParameter
function RMAnimatorController:GetParameter(name)
    for _, parameter in ipairs(self._parameters) do
        if parameter.name == name then
            return parameter
        end
    end
    return nil
end

---@param parameter RMAnimatorParameter
function RMAnimatorController:AddParameter(parameter)
    if not parameter then
        return
    end
    if self:GetParameter(parameter.name) then
        return
    end
    table.insert(self._parameters, parameter)
end

---@param parameter RMAnimatorParameter
function RMAnimatorController:RemoveParameter(parameter)
    if not parameter then
        return
    end
    for i, t in ipairs(self._parameters) do
        if t == parameter then
            table.remove(self._parameters, i)
            break
        end
    end
end

---@param name String
---@return RMAnimatorLayer
function RMAnimatorController:GetLayer(name)
    for _, layer in ipairs(self._layers) do
        if layer.name == name then
            return layer
        end
    end
    return nil
end

---@param layer RMAnimatorLayer
function RMAnimatorController:AddLayer(layer)
    if not layer then
        return
    end
    if self:GetLayer(layer.name) then
        return
    end
    table.insert(self._layers, layer)
end

---@param layer RMAnimatorLayer
function RMAnimatorController:RemoveLayer(layer)
    if not layer then
        return
    end
    for i, t in ipairs(self._layers) do
        if t == layer then
            table.remove(self._layers, i)
            break
        end
    end
end

---@param value Float
---@param prevValue Float
---@param interval Float
---@return Boolean|Float
function RMAnimatorController:IsReachingThreshold(value, prevValue, interval, threshold)
    local delta = value - prevValue
    while value > interval do
        value = value - interval
        prevValue = prevValue - interval
    end

    if prevValue < self.context.fZero then
        value = value + interval
    end

    local dValue = value - threshold
    if dValue > interval then
        dValue = dValue - interval
    end

    return (delta ~= self.context.fZero and ((prevValue + delta >= threshold and prevValue < threshold) or (value >= threshold and value - delta < threshold))), dValue
end

---@param animator RMAnimator
function RMAnimatorController:Rebuild(animator)
    ---@type RMAnimator
    self.animator = animator
    for _, layer in ipairs(self._layers) do
        local index = _
        self:_RebuildLayer(index, layer)
    end
end

---@param layer RMAnimatorLayer
function RMAnimatorController:_RebuildLayer(index, layer)
    layer:Rebuild(self, function(...)
        if self.animator and self.animator.stateNotify then
            self.animator.stateNotify:Invoke(index, ...)
        end
        self.stateNotify:Invoke(index, ...)
    end, function(...)
        if self.animator and self.animator.eventNotify then
            self.animator.eventNotify:Invoke(...)
        end
        self.eventNotify:Invoke(...)
    end)
end

return RMAnimatorController