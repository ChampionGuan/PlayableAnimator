---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chaoguan.
--- DateTime: 2021/10/11 16:00
---

---@type RMAnimatorController
local RMAnimatorController = require("Runtime.Battle.Logic.RMAnimator.RMAnimatorController")
---@type RMAnimatorCondition
local RMAnimatorCondition = require("Runtime.Battle.Logic.RMAnimator.RMAnimatorCondition")
---@type RMAnimatorState
local RMAnimatorState = require("Runtime.Battle.Logic.RMAnimator.RMAnimatorState")
---@type RMAnimatorStateTransition
local RMAnimatorStateTransition = require("Runtime.Battle.Logic.RMAnimator.RMAnimatorStateTransition")
---@type RMClipMotion
local RMClipMotion = require("Runtime.Battle.Logic.RMAnimator.RMClipMotion")
---@type RMBlendTreeChild
local RMBlendTreeChild = require("Runtime.Battle.Logic.RMAnimator.RMBlendTreeChild")
---@type RMBlendTree
local RMBlendTree = require("Runtime.Battle.Logic.RMAnimator.RMBlendTree")
---@type RMAnimatorLayer
local RMAnimatorLayer = require("Runtime.Battle.Logic.RMAnimator.RMAnimatorLayer")
---@type RMAnimatorParameter
local RMAnimatorParameter = require("Runtime.Battle.Logic.RMAnimator.RMAnimatorParameter")

---@class RMAnimatorContext
---@field fOne Float
---@field fZero Float
---@field fTen Float
---@field f90 Float
---@field f180 Float
---@field f360 Float
---@field v3Zero Vector3
---@field v3One Vector3
---@field v3Up Vector3
---@field preFrameTime Float
local RMAnimatorContext = XECS.class("RMAnimatorContext")

---@param transform XECS.Transform
function RMAnimatorContext:ctor(transform)
    self.fZero = FZero
    self.fOne = FOne
    self.fTen = FInt(10)
    self.f90 = FInt(90)
    self.f180 = FInt(180)
    self.f360 = FInt(360)
    self.v3Zero = FVector3.zero
    self.v3One = FVector3.one
    self.v3Up = FVector3(FZero, FZero, FOne)
    self.preFrameTime = FOne / FInt(30)
    self._transformScale = FVector3.one
    self._transform = transform
end

function RMAnimatorContext:Dispose()
    self._transform = nil
    self._curves = nil
end

---@param value Float
function RMAnimatorContext:Clamp01(value)
    if value < self.fZero then
        return self.fZero
    elseif value > self.fOne then
        return self.fOne
    end

    return value
end

---@param from Float
---@param to Float
function RMAnimatorContext:Lerp(from, to, t)
    return from + (to - from) * self:Clamp01(t)
end

---欧拉角度插值（保证走最短路径）
---@param from Float 原角度 0~359
---@param to Float 目标角度 0~359
---@param t Float 百分比 0~1
---@return Float 插值角度，保证走最短路径
function RMAnimatorContext:AngleLerp360(from, to, t)
    local delta = to - from
    local sign = self:Sign(delta)
    local deltaAbs = self:Abs(delta)
    if deltaAbs > self.f180 then
        if sign > self.fZero then
            from = from + self.f360
        else
            to = to + self.f360
        end
    end

    return from + (to - from) * t
end

---获取符号（+1：表示正数，-1：负数，0：0）
---@return Float
function RMAnimatorContext:Sign(num)
    if num > self.fZero then
        num = self.fOne
    elseif num < self.fZero then
        num = -self.fOne
    else
        num = self.fZero
    end

    return num
end

---@return Float
function RMAnimatorContext:GetTimeByFrame(frameIndex)
    if frameIndex == nil then
        return self.fZero
    end
    return self:Float(frameIndex) * self.preFrameTime
end

---@param realTime Float
---@return Int
function RMAnimatorContext:GetFrameByTime(realTime)
    if realTime == nil then
        return 1
    end
    return self:Int(self:Floor(realTime / self.preFrameTime)) + 1
end

---@param xz Fix|nil
---@param y Fix|nil
function RMAnimatorContext:SetTransformScale(xz, y)
    if xz then
        self._transformScale.x = xz
        self._transformScale.z = xz
    end
    if y then
        self._transformScale.y = y
    end
end

---@param deltaPos Vector3
function RMAnimatorContext:TransformTranslate(deltaPos)
    if deltaPos.x == self.v3Zero.x and deltaPos.y == self.v3Zero.y and deltaPos.z == self.v3Zero.z then
        return
    end
    deltaPos.x = deltaPos.x * self._transformScale.x
    deltaPos.z = deltaPos.z * self._transformScale.z
    deltaPos.y = deltaPos.y * self._transformScale.y

    local forward = FVector3.tempZero
    self._transform:GetWorldForward(forward)
    local right = FVector3.tempZero
    self._transform:GetWorldRight(right)
    local up = FVector3.tempZero
    up.y = deltaPos.y
    local finalPos = FVector3.tempZero
    self._transform:GetWorldPosition(finalPos)
    self._transform:SetWorldPosition(self:V3AddEqualTo(finalPos, self:V3MulEqualTo(forward, deltaPos.z), up, self:V3MulEqualTo(right, deltaPos.x)))
end

---@param deltaAngleY Float
function RMAnimatorContext:TransformRotate(deltaAngleY)
    if deltaAngleY == self.zero then
        return
    end

    self._transform:SetWorldAngleY(deltaAngleY + self._transform:GetWorldAngleY())
end

---@param deltaPos Vector3
---@param angleY Float
function RMAnimatorContext:PointRotate(deltaPos, angleY)
    if angleY and angleY ~= self.fZero then
        local forward, right = FVector3.tempZero, FVector3.tempZero
        self.v3Up:GetRotatedVector3NG(angleY, forward)
        forward:GetRotatedVector3NG(self.f90, right)
        return self:V3AddEqualTo(self:V3MulEqualTo(forward, deltaPos.z), self:V3MulEqualTo(right, deltaPos.x))
    else
        return deltaPos
    end
end

function RMAnimatorContext:ReadCurve(name)
    if not name then
        return {}
    end

    if not self._curves then
        self._curves = {}
    end

    local date = self._curves[name]
    if not date then
        date = g_BattleMgr.file:ReadRMBinary(name)
        self._curves[name] = date or {}
    end
    return date
end

---@return Float
function RMAnimatorContext:Floor(num)
    return MathFix.Floor(num)
end

---@return Int
function RMAnimatorContext:Int(num)
    return to_int(num)
end

---@return Float
function RMAnimatorContext:Float(num)
    return FInt(num)
end

---@return Float
function RMAnimatorContext:FloatTM(num)
    return FIntTM(num)
end

---@return Float
function RMAnimatorContext:Abs(num)
    return MathFix.Abs(num)
end

---@return table
function RMAnimatorContext:V3(x, y, z)
    return FVector3(x, y, z)
end

---@return Vector3
function RMAnimatorContext:V3Zero()
    return FVector3.zero
end

---@return Vector3
function RMAnimatorContext:V3TempZero()
    return FVector3.tempZero
end

function RMAnimatorContext:V3Copy(result, va)
    result.x = va.x
    result.y = va.y
    result.z = va.z
    return result
end

---取反
---@param va Vector3
function RMAnimatorContext:V3Unm(result, va)
    result.x = -va.x
    result.y = -va.y
    result.z = -va.z
    return result
end

---加等于
function RMAnimatorContext:V3AddEqualTo(result, ...)
    local length = select("#", ...)
    for index = 1, length do
        result:Add(select(index, ...))
    end
    return result
end

---乘等于
function RMAnimatorContext:V3MulEqualTo(result, ...)
    local length = select("#", ...)
    for index = 1, length do
        result:Mul(select(index, ...))
    end
    return result
end

---@return Vector3
function RMAnimatorContext:FTempZero()
    return self.fZero
end

---取反
---@param va Vector3
function RMAnimatorContext:FUnm(result, va)
    result = -va
    return result
end

---加等于
function RMAnimatorContext:FAddEqualTo(result, ...)
    local length = select("#", ...)
    for index = 1, length do
        result = result + select(index, ...)
    end
    return result
end

---乘等于
function RMAnimatorContext:FMulEqualTo(result, ...)
    local length = select("#", ...)
    for index = 1, length do
        result = result * select(index, ...)
    end
    return result
end

---@param ctrlConfig AnimatorCtrlConfig
---@param eventConfig EventConfig
function RMAnimatorContext:CreateAnimatorCtrl(ctrlConfig, eventConfig)
    local ctrl = RMAnimatorController.new(self)
    if not ctrlConfig or not ctrlConfig.parameters or not ctrlConfig.layers then
        Debug.LogErrorFormat("【RMAnimator】动画状态机创建失败，请检查配置！")
        return ctrl
    end

    ---@param parameter AnimatorCtrlParameterConfig
    for _, parameter in ipairs(ctrlConfig.parameters) do
        ctrl:AddParameter(RMAnimatorParameter.new(parameter.name, parameter.type, parameter.value))
    end

    eventConfig = eventConfig or {}
    ---@param layer AnimatorCtrlLayerConfig
    for index, layer in ipairs(ctrlConfig.layers) do
        ---只取第一层
        if index > 1 then
            break
        end
        local states = {}
        for _, state in ipairs(layer.states) do
            local transitions = {}
            for _, transition in ipairs(state.transitions) do
                local conditions = {}
                for _, condition in ipairs(transition.conditions) do
                    table.insert(conditions, RMAnimatorCondition.new(condition.type, condition.parameterName, condition.threshold))
                end
                table.insert(transitions, RMAnimatorStateTransition.new(transition.hasExitTime, transition.hasFixedDuration, transition.offset, transition.duration, transition.exitTime, transition.destinationStateName, transition.solo, transition.mute, conditions))
            end
            local motion = nil
            if state.blendTree then
                local childMotions = {}
                for _, childMotion in ipairs(state.blendTree.childMotions) do
                    table.insert(childMotions, RMBlendTreeChild.new(ctrl, childMotion.threshold, childMotion.clip, eventConfig[childMotion.clip.name]))
                end
                motion = RMBlendTree.new(ctrl, state.blendTree.minThreshold, state.blendTree.maxThreshold, state.blendTree.blendParameterName, state.blendTree.blendType, childMotions)
            else
                motion = RMClipMotion.new(ctrl, state.soloClip, eventConfig[state.soloClip.name])
            end
            table.insert(states, RMAnimatorState.new(ctrl, state.name, state.tag, state.defaultSpeed, state.speedParameterName, state.speedParameterActive, state.formSubStateMachineName, motion, transitions))
        end
        ctrl:AddLayer(RMAnimatorLayer.new(layer.name, layer.defaultSpeed, layer.defaultStateName, states))
    end
    return ctrl
end

return RMAnimatorContext